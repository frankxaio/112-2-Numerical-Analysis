# Final 

| 系級     | 學號     | 姓名   |
| -------- | -------- | ------ |
| 電子三乙 | B1027234 | 林永濬 |
| 電子三乙 | B1027236 | 蕭銘宏 |

## Introduction

完整的數位通訊系統的模擬。數位通訊系統由多個模組組成,每個模組在這裡都是以MATLAB函式的形式實現的,而'main_code.m'檔案將它們組合在一起,構建出完整的系統。該系統從Data資料夾中讀取文字檔案'source_data.txt',並相應地處理文字資料,然後將接收到的文字寫入Data資料夾中名為'received.txt'的另一個文字檔案。下面的方塊圖以順序的方式顯示了系統的所有模組。

![](https://user-images.githubusercontent.com/37298971/52767116-acbd0b80-3053-11e9-9998-4dd80c8a2825.png)

## Theory

### Source Coding: Huffman encoding 

Huffman編碼廣泛應用於各種資料壓縮領域,如文字壓縮、圖像壓縮、音訊壓縮等。它是一種理論上最優的前綴碼,能夠在無失真的情況下實現資料的壓縮。

Huffman編碼的特點是,出現頻率高的符號被分配了較短的編碼,出現頻率低的符號被分配了較長的編碼。**這樣可以有效地減少編碼後資料的總長度,達到壓縮的目的**。

> [!NOTE]
>
> Huffman編碼的步驟如下:
>
> 1. 統計資料中各個符號的出現頻率。
>
> 2. 根據頻率建立一個符號表,並按照頻率從小到大排序。
>
> 3. 選擇頻率最小的兩個符號,建立一個新的節點,該節點的頻率為兩個子節點頻率之和。
>
> 4. 將新建立的節點加入符號表中,並重複步驟3,直到符號表中只剩下一個節點為止。
>
> 5. 從根節點開始,為左子樹分配二元碼0,為右子樹分配二元碼1,直到所有的葉子節點都被分配了編碼。
>
> 6. 根據建立的編碼表,將原始資料轉換為二元編碼序列。
>

> reference: [Huffman Coding](https://medium.com/@vanijain112/huffman-coding-5c321e769179)

### Channel encoding: Convolutional encoding

Channel Coding(信道編碼)是數位通訊系統中的一種重要技術,其目的是在資料傳輸過程中增加一定的冗餘資訊,以提高資料傳輸的可靠性。我們採用的 Convolutional encoding(卷積編碼) 實現 channel encoding。卷積編碼的基本原理是將輸入資料序列與一個或多個生成多項式進行卷積運算,產生編碼後的輸出序列。

> [!NOTE]
>
> **卷積編碼步驟:**
>
> 1. 定義一個或多個生成多項式,表示為二進位序列。
>
> 2. 將輸入資料序列分組,每組長度為k個位元。
>
> 3. 對每個輸入資料組,使用生成多項式進行卷積運算,產生n個位元的輸出(n > k)。
>
> 4. 將所有輸出位元組合成編碼後的序列。
>
>**卷積編碼的特點是:**
> 
>1. 編碼後的輸出序列不僅與當前輸入資料有關,還與之前的輸入資料有關,因此具有一定的記憶性。
> 
>2. 編碼率(k/n)可以根據需要進行調整,以平衡資料傳輸速率和可靠性。
> 
>3. 卷積編碼可以使用維特比演算法(Viterbi Algorithm)進行最大似然解碼,在接收端恢復原始資料。

> reference: [Intro to Convolutional Coding — Part I](https://medium.com/nerd-for-tech/into-to-convolutional-coding-part-i-d63decab56a0)

### Modulation: ASK, FSK, PSK,  

> [!NOTE]
>
> | Analog                             | Digital                                   |
> | ---------------------------------- | ----------------------------------------- |
> | 振幅調變(Amplitude Modulation, AM) | 振幅偏移鍵制(Amplitude Shift Keying, ASK) |
> | 頻率調變(Frequency Modulation, FM) | 頻率偏移鍵制(Frequency Shift Keying, FSK) |
> | 相位調變(Phase Modulation, PM)     | 相位偏移鍵制(Phase Shift Keying, PSK)。   |
>
> 正交振幅調變(Quadrature Amplitude Modulation, QAM)，結合了PSK、ASK，同時控制振幅與相位，一個訊號能代表更多的資料。

| 調變/解調 | 優點                                                         | 缺點                                                         |
| --------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| BASK      | - 實現簡單,硬體複雜度低<br>- 解調門檻容易確定<br>- 抗衰落能力較好 | - 頻譜利用率低<br>- 抗噪聲能力較差<br>- 容易受到幅度非線性影響 |
| BPSK      | - 抗噪聲能力強<br>- 頻譜利用率高<br>- 適用於長距離傳輸       | - 實現複雜度較高<br>- 對相位同步要求嚴格<br>- 解調門檻需要準確估計 |
| QPSK      | - 頻譜利用率高<br>- 傳輸速率高<br>- 抗噪聲能力強             | - 實現複雜度高<br>- 對相位同步要求嚴格<br>- 解調需要精確的同相和正交分量估計 |

以下是對表格內容的詳細說明:

1. BASK (Binary Amplitude Shift Keying):
   - 優點:
     - 實現簡單,硬體複雜度低:BASK 解調只需要比較接收信號的幅度與門檻值,硬體實現相對簡單。
     - 解調門檻容易確定:BASK 的解調門檻通常取最大和最小幅度的平均值,易於確定。
     - 抗衰落能力較好:BASK 對信號幅度的變化不太敏感,因此抗衰落能力較好。
   - 缺點:
     - 頻譜利用率低:BASK 調製的頻譜效率較低,每個符號只能傳輸一個比特的信息。
     - 抗噪聲能力較差:BASK 對噪聲干擾比較敏感,容易受到噪聲的影響。
     - 容易受到幅度非線性影響:BASK 容易受到發射機和接收機中的非線性因素影響,導致幅度失真。

2. BPSK (Binary Phase Shift Keying):
   - 優點:
     - 抗噪聲能力強:BPSK 將信息編碼在相位上,對噪聲干擾的抵抗能力較強。
     - 頻譜利用率高:BPSK 的頻譜效率比 BASK 高,每個符號可以傳輸一個比特的信息。
     - 適用於長距離傳輸:BPSK 的抗噪聲能力使其適用於長距離傳輸。
   - 缺點:
     - 實現複雜度較高:BPSK 解調需要精確的相位同步和相干解調,實現複雜度較高。
     - 對相位同步要求嚴格:BPSK 對接收端的相位同步要求嚴格,否則會導致解調錯誤。
     - 解調門檻需要準確估計:BPSK 的解調門檻為 0,需要準確估計接收信號的相位。

3. QPSK (Quadrature Phase Shift Keying):
   - 優點:
     - 頻譜利用率高:QPSK 每個符號可以傳輸兩個比特的信息,頻譜效率是 BPSK 的兩倍。
     - 傳輸速率高:QPSK 的傳輸速率是 BPSK 的兩倍,在相同帶寬下可以傳輸更多的數據。
     - 抗噪聲能力強:QPSK 將信息編碼在相位上,對噪聲干擾的抵抗能力較強。
   - 缺點:
     - 實現複雜度高:QPSK 解調需要同相和正交兩路解調,實現複雜度較高。
     - 對相位同步要求嚴格:QPSK 對接收端的相位同步要求嚴格,否則會導致解調錯誤。
     - 解調需要精確的同相和正交分量估計:QPSK 解調需要準確估計接收信號的同相和正交分量。

> **BASK 實現簡單但頻譜利用率和抗噪聲能力較差；BPSK 抗噪聲能力強，適用於長距離傳輸，但實現複雜度較高；QPSK 頻譜利用率高，傳輸速率高，但實現複雜度也較高。**

### Channel: Additive White Gaussian Noise Channel

### Channel Decoding: Viterbi decoding

維特比解碼（Viterbi Decoding）的方法，它是一種用於解碼卷積碼（Convolutional Code）的最大似然序列估計（Maximum Likelihood Sequence Estimation, MLSE）算法。

維特比解碼的原理是基於動態規劃（Dynamic Programming）的思想，通過在卷積碼的trellis圖上進行最短路徑搜索，找到最可能生成接收序列的狀態序列，從而得到最可能的發送序列。

為了理解維特比解碼，我們可以通過一個簡單的例子來說明：

假設我們有一個卷積碼，其生成矩陣為：

```
Copy codeG = [1 1 1;
     1 0 1];
```

約束長度（Constraint Length）為3，編碼率為1/2。

現在，我們收到一個編碼後的序列：`y = [1 1 0 1 0 0 1 1]`。

我們希望使用維特比解碼來找到最可能的發送序列。

步驟如下：

1. 構建trellis圖：根據生成矩陣和約束長度，我們可以構建一個trellis圖，其中每個節點表示一個狀態，每條邊表示一個可能的狀態轉移。
2. 計算路徑度量（Path Metric）：對於每個時刻和每個狀態，我們計算從起始狀態到當前狀態的路徑度量。路徑度量是沿著路徑的分支度量（Branch Metric）之和，分支度量是接收符號與期望符號之間的漢明距離（Hamming Distance）。
3. 生存路徑選擇（Survivor Path Selection）：對於每個時刻和每個狀態，我們選擇具有最小路徑度量的路徑作為生存路徑。
4. 回溯（Traceback）：在達到最後一個時刻後，我們從具有最小路徑度量的狀態開始，沿著生存路徑回溯，得到最可能的狀態序列，並根據狀態序列得到最可能的發送序列。

讓我們應用維特比解碼來解碼上述例子中的接收序列：

1. 構建trellis圖：對於約束長度為3的卷積碼，trellis圖有4個狀態（00, 01, 10, 11）。
2. 計算路徑度量：對於每個時刻和每個狀態，計算路徑度量。例如，在時刻1，狀態00的路徑度量為0，因為它是起始狀態；狀態01的路徑度量為2，因為接收符號為11，而期望符號為00或11。
3. 生存路徑選擇：對於每個時刻和每個狀態，選擇具有最小路徑度量的路徑作為生存路徑。
4. 回溯：在達到最後一個時刻後，從具有最小路徑度量的狀態開始回溯，得到最可能的狀態序列，並根據狀態序列得到最可能的發送序列。

通過維特比解碼，我們可以得到最可能的發送序列為：`[1 0 1 0]`。

這僅僅是一個簡單的例子，實際應用中的卷積碼和接收序列可能更加複雜。維特比解碼通過在trellis圖上進行最短路徑搜索，有效地解碼卷積碼，並在現代通信系統中得到廣泛應用。

## Example 

以 `text = Hello World` 為例子

### Source Statistics

計算每個字元出現的頻率獲得 Huffman encoding 的資訊

`length(Hello world) = 11`

| Char(descending) | Count | Huffman |
| ---------------- | ----- | ------- |
| l                | 3     | 10      |
| o                | 2     | 01      |
| "space"          | 1     | 001     |
| H                | 1     | 000     |
| d                | 1     | 1111    |
| e                | 1     | 1110    |
| r                | 1     | 1101    |
| w                | 1     | 1100    |

| Char(descending) | Count | Frequency               | Huffman |
| ---------------- | ----- | ----------------------- | ------- |
| l                | 3     | $\frac{3}{11}=0.2727$   | 10      |
| o                | 2     | $\frac{2}{11}=0.1818$   | 01      |
| "space"          | 1     | $$\frac{1}{11}=0.0909$$ | 001     |
| H                | 1     | $$\frac{1}{11}=0.0909$$ | 000     |
| d                | 1     | $$\frac{1}{11}=0.0909$$ | 1111    |
| e                | 1     | $$\frac{1}{11}=0.0909$$ | 1110    |
| r                | 1     | $$\frac{1}{11}=0.0909$$ | 1101    |
| w                | 1     | $$\frac{1}{11}=0.0909$$ | 1100    |

### Huffman Encoding

![image-20240528182422131](https://raw.githubusercontent.com/frankxaio/markdwon-image/main/data/image-20240528182422131.png)

### Bitstream 

| H    | e    | l    | l    | o    | " "  | w    | o    | r    | l    | d    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 000  | 1110 | 10   | 10   | 01   | 001  | 1100 | 01   | 1101 | 10   | 1111 |

### Convolutional coding 

![image-20240528223331922](https://raw.githubusercontent.com/frankxaio/markdwon-image/main/data/image-20240528223331922.png)

### Modulation 

![](https://upload.wikimedia.org/wikipedia/commons/thumb/e/e7/Modulation_categorization.svg/1920px-Modulation_categorization.svg.png)

```matlab
samples_per_bit = 40; 
Rb = 1000; 
amp = [1 0];
freq = 1000;                         
snr = 10; 
Generator = [1 1 1; 1 0 1]; 
shift = 1; 
```

#### BASK 

同一個載波以振福大小表示 0,1

![image-20240528230523898](https://raw.githubusercontent.com/frankxaio/markdwon-image/main/data/image-20240528230523898.png)

#### BPSK 

用相位差為 $\pi$ 的兩個載波，分別代表0,1。

![image-20240528230548062](https://raw.githubusercontent.com/frankxaio/markdwon-image/main/data/image-20240528230548062.png)

#### QPSK 

使用四個正交的載波，將 Bitstream 的 bits 倆倆分組，並映射成格雷碼(Grey code)，每一組格雷碼分別對應一個載波。

> [!Note]
>
> **格雷碼(Grey code)** 
>
> 使用 Gray 碼進行編碼的目的是為了最小化相鄰符號之間的比特差異,減少解調錯誤。當接收到的信號受到噪聲或干擾影響時,如果相鄰符號之間的比特差異較小,則錯誤解調的可能性較小。
>
> | Decimal Value | Binary Code | Gray Code |
> | ------------- | ----------- | --------- |
> | 0             | 00          | 00        |
> | 1             | 01          | 01        |
> | 2             | 10          | 11        |
> | 3             | 11          | 10        |
>
> **星座圖(Constellation diagram)**
>
> ![image-20240528231830968](https://raw.githubusercontent.com/frankxaio/markdwon-image/main/data/image-20240528231830968.png)

![image-20240528230607383](https://raw.githubusercontent.com/frankxaio/markdwon-image/main/data/image-20240528230607383.png)



### Channel 

$$
\text{SNR} = 10\log(Ps/Pn) \quad(\text{dB})
$$

- $P_s:$ 訊號有效功率
- $P_n:$ 噪聲有效功率

使用加性高斯雜訊(Additive white Gaussian noise，AWGN) 模擬通道傳輸。

### Demodulation

1. BASK (Binary Amplitude Shift Keying) 解調:

   - BASK 解調的原理是根據接收信號的幅度來判斷傳輸的比特值。
   - 首先,將接收到的信號 `received` 與載波信號 `sin(2*pi*freq(1)*t)` 相乘,得到基帶信號 `r`。
   - 然後,將基帶信號 `r` 按照每個比特的樣本數 `k` 進行重塑,得到一個矩陣,每一行對應一個比特的樣本值。
   - 對每一行樣本值求平均,得到解調後的值 `yd`。
   - 設置一個閾值 `threshold`,通常為最大幅度 `a1` 和最小幅度 `a0` 的平均值的一半,即 `(a0 + a1) / 4`。
   - 將解調值 `yd` 與閾值進行比較,大於等於閾值的為比特 1,小於閾值的為比特 0。

   例如,假設接收到的 BASK 調製信號的幅度為 [1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1],最大幅度 `a1`為 1,最小幅度 `a0`

    為 0,閾值為 (1 + 0) / 4 = 0.25。通過 BASK 解調,得到的解調值 `yd` 可能為 [0.9, 0.1, 0.95],與閾值比較後,得到解調後的比特流為 [1, 0, 1]。

2. BPSK (Binary Phase Shift Keying) 解調:

   - BPSK 解調的原理是根據接收信號的相位來判斷傳輸的比特值。
   - 與 BASK 類似,首先將接收到的信號與載波信號相乘,得到基帶信號 `r`。
   - 將基帶信號按照每個比特的樣本數進行重塑,得到一個矩陣。
   - 對每一行樣本值求平均,得到解調後的值 `yd`。
   - 設置閾值 `threshold` 為 0,將解調值 `yd` 與閾值進行比較,大於等於閾值的為比特 1,小於閾值的為比特 0。

   例如,假設接收到的 BPSK 調製信號的相位為 [0, 0, 0, 0, π, π, π, π, 0, 0, 0, 0],對應的解調值 `yd` 可能為 [0.8, -0.9, 0.7],與閾值 0 比較後,得到解調後的比特流為 [1, 0, 1]。

3. QPSK (Quadrature Phase Shift Keying) 解調:

   - QPSK 解調的原理是根據接收信號在同相 (I) 和正交 (Q) 分量上的投影來判斷傳輸的符號。
   - 將接收到的信號分別與同相載波 `sin(2*pi*f*t)` 和正交載波 `cos(2*pi*f*t)` 相乘,得到同相分量 `r1` 和正交分量 `r2`。
   - 對 `r1` 和 `r2` 求平均,得到同相分量的平均值 `ai` 和正交分量的平均值 `aq`。
   - 計算星座圖中每個點 (符號) 與接收信號 (`ai`, `aq`) 的歐氏距離,選擇距離最小的點作為解調後的符號。
   - 將解調後的符號轉換為對應的比特序列。

   例如,假設 QPSK 星座圖中的四個點分別為 (1, 1), (-1, 1), (-1, -1), (1, -1),對應的符號為 00, 01, 11, 10。如果接收到的信號經過解調後得到同相分量 `ai`為 0.8,正交分量 `aq` 為 0.9,則與四個點的距離分別為:

   - (1, 1): (1 - 0.8)^2 + (1 - 0.9)^2 = 0.05
   - (-1, 1): (-1 - 0.8)^2 + (1 - 0.9)^2 = 3.25
   - (-1, -1): (-1 - 0.8)^2 + (-1 - 0.9)^2 = 7.25
   - (1, -1): (1 - 0.8)^2 + (-1 - 0.9)^2 = 3.65 距離最小的點為 (1, 1),對應的符號為 00,因此解調後的比特序列為 [0, 0]。

